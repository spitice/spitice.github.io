"use strict";(self.webpackChunkweb_replay_tools=self.webpackChunkweb_replay_tools||[]).push([[728,960,848],{848:(e,t,i)=>{i.r(t),i.d(t,{FileHandle:()=>a,FolderHandle:()=>o,default:()=>r});const n=i(960).errors["DISALLOWED"];class s{constructor(e,t){this.writer=e,this.fileEntry=t}async write(i){if("object"==typeof i)if("write"===i.type){if(Number.isInteger(i.position)&&0<=i.position&&(this.writer.seek(i.position),this.writer.position!==i.position)&&(await new Promise((e,t)=>{this.writer.onwriteend=e,this.writer.onerror=t,this.writer.truncate(i.position)}),this.writer.seek(i.position)),!("data"in i))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument","SyntaxError");i=i.data}else{if("seek"===i.type){if(Number.isInteger(i.position)&&0<=i.position){if(this.writer.seek(i.position),this.writer.position!==i.position)throw new DOMException("seeking position failed","InvalidStateError");return}throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument","SyntaxError")}if("truncate"===i.type)return new Promise(t=>{if(!(Number.isInteger(i.size)&&0<=i.size))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument","SyntaxError");this.writer.onwriteend=e=>t(),this.writer.truncate(i.size)})}await new Promise((e,t)=>{this.writer.onwriteend=e,this.writer.onerror=t,this.writer.write(new Blob([i]))})}close(){return new Promise(this.fileEntry.file.bind(this.fileEntry))}}class a{constructor(e,t=!0){this.file=e,this.kind="file",this.writable=t,this.readable=!0}get name(){return this.file.name}isSameEntry(e){return this.file.toURL()===e.file.toURL()}getFile(){return new Promise(this.file.file.bind(this.file))}createWritable(r){if(this.writable)return new Promise((i,e)=>this.file.createWriter(t=>{!1===r.keepExistingData?(t.onwriteend=e=>i(new s(t,this.file)),t.truncate(0)):i(new s(t,this.file))},e));throw new DOMException(...n)}}class o{constructor(e,t=!0){this.dir=e,this.writable=t,this.readable=!0,this.kind="directory",this.name=e.name}isSameEntry(e){return this.dir.fullPath===e.dir.fullPath}async*entries(){var e=this.dir.createReader();for(const t of await new Promise(e.readEntries.bind(e)))yield[t.name,new(t.isFile?a:o)(t,this.writable)]}getDirectoryHandle(i,r){return new Promise((t,e)=>{this.dir.getDirectory(i,r,e=>{t(new o(e))},e)})}getFileHandle(i,r){return new Promise((t,e)=>this.dir.getFile(i,r,e=>t(new a(e)),e))}async removeEntry(t,i){const r=await this.getDirectoryHandle(t,{create:!1}).catch(e=>"TypeMismatchError"===e.name?this.getFileHandle(t,{create:!1}):e);if(r instanceof Error)throw r;return new Promise((e,t)=>{r instanceof o?i.recursive?r.dir.removeRecursively(()=>e(),t):r.dir.remove(()=>e(),t):r.file&&r.file.remove(()=>e(),t)})}}const r=(i={})=>new Promise((t,e)=>window.webkitRequestFileSystem(i._persistent,0,e=>t(new o(e.root)),e))},960:(e,t,o)=>{o.r(t),o.d(t,{config:()=>r,errors:()=>i,fromDataTransfer:()=>async function(e){console.warn("deprecated fromDataTransfer - use `dt.items[0].getAsFileSystemHandle()` instead");const[t,i,r]=await Promise.all([o.e(64).then(o.bind(o,64)),o.e(848).then(o.bind(o,848)),Promise.resolve().then(o.bind(o,232))]),n=new t.FolderHandle("",!1);return n._entries=e.map(e=>new(e.isFile?i.FileHandle:i.FolderHandle)(e,!1)),new r.FileSystemDirectoryHandle(n)},getDirHandlesFromInput:()=>async function(e){const{FolderHandle:r,FileHandle:n}=await o.e(64).then(o.bind(o,64)),t=(await Promise.resolve().then(o.bind(o,232)))["FileSystemDirectoryHandle"],i=Array.from(e.files),s=i[0].webkitRelativePath.split("/",1)[0],a=new r(s,!1);return i.forEach(e=>{var t=e.webkitRelativePath.split("/"),i=(t.shift(),t.pop());t.reduce((e,t)=>(e._entries[t]||(e._entries[t]=new r(t,!1)),e._entries[t]),a)._entries[i]=new n(e.name,e,!1)}),new t(a)},getFileHandlesFromInput:()=>async function(e){const t=(await o.e(64).then(o.bind(o,64)))["FileHandle"],i=(await Promise.resolve().then(o.bind(o,600)))["FileSystemFileHandle"];return Array.from(e.files).map(e=>new i(new t(e.name,e,!1)))}});const i={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:e=>["Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. "+e,"SyntaxError"],SECURITY:["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.","SecurityError"],DISALLOWED:["The request is not allowed by the user agent or the platform in the current context.","NotAllowedError"]},r={writable:globalThis.WritableStream}}}]);