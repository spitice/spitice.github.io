"use strict";(self.webpackChunkweb_replay_tools=self.webpackChunkweb_replay_tools||[]).push([[848],{1848:(e,i,t)=>{t.r(i),t.d(i,{FileHandle:()=>o,FolderHandle:()=>a,default:()=>r});const n=t(2960).errors["DISALLOWED"];class s{constructor(e,i){this.writer=e,this.fileEntry=i}async write(t){if("object"==typeof t)if("write"===t.type){if(Number.isInteger(t.position)&&0<=t.position&&(this.writer.seek(t.position),this.writer.position!==t.position)&&(await new Promise((e,i)=>{this.writer.onwriteend=e,this.writer.onerror=i,this.writer.truncate(t.position)}),this.writer.seek(t.position)),!("data"in t))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument","SyntaxError");t=t.data}else{if("seek"===t.type){if(Number.isInteger(t.position)&&0<=t.position){if(this.writer.seek(t.position),this.writer.position!==t.position)throw new DOMException("seeking position failed","InvalidStateError");return}throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument","SyntaxError")}if("truncate"===t.type)return new Promise(i=>{if(!(Number.isInteger(t.size)&&0<=t.size))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument","SyntaxError");this.writer.onwriteend=e=>i(),this.writer.truncate(t.size)})}await new Promise((e,i)=>{this.writer.onwriteend=e,this.writer.onerror=i,this.writer.write(new Blob([t]))})}close(){return new Promise(this.fileEntry.file.bind(this.fileEntry))}}class o{constructor(e,i=!0){this.file=e,this.kind="file",this.writable=i,this.readable=!0}get name(){return this.file.name}isSameEntry(e){return this.file.toURL()===e.file.toURL()}getFile(){return new Promise(this.file.file.bind(this.file))}createWritable(r){if(this.writable)return new Promise((t,e)=>this.file.createWriter(i=>{!1===r.keepExistingData?(i.onwriteend=e=>t(new s(i,this.file)),i.truncate(0)):t(new s(i,this.file))},e));throw new DOMException(...n)}}class a{constructor(e,i=!0){this.dir=e,this.writable=i,this.readable=!0,this.kind="directory",this.name=e.name}isSameEntry(e){return this.dir.fullPath===e.dir.fullPath}async*entries(){var e=this.dir.createReader();for(const i of await new Promise(e.readEntries.bind(e)))yield[i.name,new(i.isFile?o:a)(i,this.writable)]}getDirectoryHandle(t,r){return new Promise((i,e)=>{this.dir.getDirectory(t,r,e=>{i(new a(e))},e)})}getFileHandle(t,r){return new Promise((i,e)=>this.dir.getFile(t,r,e=>i(new o(e)),e))}async removeEntry(i,t){const r=await this.getDirectoryHandle(i,{create:!1}).catch(e=>"TypeMismatchError"===e.name?this.getFileHandle(i,{create:!1}):e);if(r instanceof Error)throw r;return new Promise((e,i)=>{r instanceof a?t.recursive?r.dir.removeRecursively(()=>e(),i):r.dir.remove(()=>e(),i):r.file&&r.file.remove(()=>e(),i)})}}const r=(t={})=>new Promise((i,e)=>window.webkitRequestFileSystem(t._persistent,0,e=>i(new a(e.root)),e))}}]);